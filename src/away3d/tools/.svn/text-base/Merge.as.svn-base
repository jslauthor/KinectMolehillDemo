package away3d.tools{	import away3d.arcane;	import away3d.core.base.Geometry;	import away3d.core.base.data.Vertex;	import away3d.core.base.SubGeometry;	import away3d.entities.Mesh;	import away3d.containers.ObjectContainer3D;	import away3d.materials.MaterialBase;		import flash.geom.Matrix3D;	import flash.geom.Vector3D;	use namespace arcane;	/**	*  Class Merge merges two or more meshes into one.<code>Merge</code>	*  Doesn't support Animation Merging (yet)	*/	public class Merge{				private const LIMIT:uint = 64998;		private var _m1:Mesh;		private var _objectspace:Boolean;		private var _keepMaterial:Boolean;		private var _disposeSources:Boolean;		private var _holder:Vector3D;		  		/**		* @param	 objectspace		[optional] Boolean. Defines if mesh2 is merge using its objectspace or worldspace. Default is false.		* @param	 keepMaterial		[optional] Boolean. Defines if the merged object uses the mesh1 material information or keeps its material(s). Default is false.		* If set to false and reciever object has multiple materials, the last material found in mesh1 submeshes is applied to mesh2 submeshes. 		* @param	 disposeSources	[optional] Boolean. Defines if mesh2 (or sources meshes in case applyToContainer is used) are kept untouched or disposed. Default is false.		* If keepMaterial is true, only geometry and eventual ObjectContainers3D are cleared from memory.		*/				function Merge(objectspace:Boolean = false, keepMaterial:Boolean = false, disposeSources:Boolean = false):void		{			_objectspace = objectspace;			_keepMaterial = keepMaterial;			_disposeSources = disposeSources;		}				/**		* Defines if the mesh(es) sources used for the merging are kept or disposed.		*/		public function set disposeSources(b:Boolean):void		{			_disposeSources = b;		}				public function get disposeSources():Boolean		{			return _disposeSources;		}		/**		* Defines if mesh2 will be merged using its own material information.		*/		public function set keepmaterial(b:Boolean):void		{			_keepMaterial = b;		}				public function get keepMaterial():Boolean		{			return _keepMaterial;		}				/**		* Defines if mesh2 is merged using its objectspace.		*/		public function set objectspace(b:Boolean):void		{			_objectspace = b;		}				public function get objectspace():Boolean		{			return _objectspace;		}				/**		*  Merges all the children of a container as one single Mesh.		* 	The first Mesh child encountered becomes the reciever. This is mesh that is returned.		* 	If no Mesh object is found, class returns null.		* @param	 objectContainer		*		* @return The merged Mesh instance		*/		public function applyToContainer(object:ObjectContainer3D):Mesh		{			_m1 = null;			parseContainer(object);						if(_disposeSources)				object = null;						return _m1;		}		 		/**		*  Merge 2 meshes into one		* @param	 mesh1				Mesh. The receiver object that will hold both meshes information.		* @param	 mesh2				Mesh. The Mesh object to be merge with mesh1.		*/		public function apply(mesh1:Mesh, mesh2:Mesh):void		{			var j : uint;			var i : uint;						if(!_objectspace){				var v:Vertex = new Vertex();				var t:Matrix3D = mesh2.transform;								var scenePosX:Number = mesh2.scenePosition.x - mesh1.scenePosition.x;				var scenePosY:Number = mesh2.scenePosition.y - mesh1.scenePosition.y;				var scenePosZ:Number = mesh2.scenePosition.z - mesh1.scenePosition.z;			}						var geometry:Geometry = mesh1.geometry;			var geometries:Vector.<SubGeometry> = geometry.subGeometries;			var numSubGeoms:int = geometries.length;						var vertices:Vector.<Number>;			var indices:Vector.<uint>;			var uvs:Vector.<Number>;						var vectors:Array = [];			var materials:Array = [];						for (i = 0; i<mesh1.subMeshes.length; ++i){				materials.push(mesh1.subMeshes[i].material);			}						if(_keepMaterial){				var hasMaterial:Boolean;				var nmaterials:Array = [];				for (i = 0; i<mesh2.subMeshes.length; ++i){					nmaterials.push((mesh2.material == null)? mesh2.subMeshes[i].material : mesh2.material);					if(!hasMaterial && nmaterials[i] != null)						hasMaterial = true;				}			}						for (i = 0; i<numSubGeoms; ++i){					 				vertices = new Vector.<Number>();				indices = new Vector.<uint>();				uvs = new Vector.<Number>();				vertices = SubGeometry(geometries[i]).vertexData.concat();				indices = SubGeometry(geometries[i]).indexData.concat();				uvs = SubGeometry(geometries[i]).UVData.concat();								vectors.push([vertices,indices,uvs]);			}						var nvertices:Vector.<Number>;			var nindices:Vector.<uint>;			var nuvs:Vector.<Number>;						var addSubgeom:Boolean;			if(_keepMaterial && hasMaterial && nmaterials[0] != materials[materials.length-1])				addSubgeom = true;						nvertices = vectors[vectors.length-1][0];			nindices = vectors[vectors.length-1][1];			nuvs = vectors[vectors.length-1][2];						var nIndex:uint = nvertices.length;			var nIndexind:uint = nindices.length;			var nIndexuv:uint = nuvs.length;						var index:uint;			var indexuv:uint;			var indexind:uint;						var vecLength : uint;			var subGeom:SubGeometry;						var geometry2:Geometry = mesh2.geometry;			var geometriesM2:Vector.<SubGeometry> = geometry2.subGeometries;			numSubGeoms = geometriesM2.length;						var lockIndex:uint = nIndexind;						for (i = 0; i < numSubGeoms; ++i){				subGeom = SubGeometry(geometriesM2[i]);				vertices = subGeom.vertexData;				indices = subGeom.indexData;				uvs = subGeom.UVData;								if(_keepMaterial){					materials.push((mesh2.material == null)? nmaterials[i] : mesh2.material);				} else{					materials.push((mesh1.material == null)? materials[i] : mesh1.material);				}				vecLength = (i == 0)? lockIndex : indices.length;								for (j = 0; j < vecLength;++j){					index = indices[j]*3;					indexuv = indices[j]*2;										if(nvertices.length+3 > LIMIT || addSubgeom){						addSubgeom = false;						nIndexind = 0;						nIndex = 0;						nIndexuv = 0;						nvertices = new Vector.<Number>();						nindices = new Vector.<uint>();						nuvs =new Vector.<Number>();						vectors.push([nvertices,nindices,nuvs]);						subGeom = new SubGeometry();						geometry.addSubGeometry(subGeom);												materials.push(materials.length-1);					}										nindices[nIndexind++] = nvertices.length/3;										if(_objectspace){						nvertices[nIndex++] = vertices[index];						nvertices[nIndex++] = vertices[index+1]+250;						nvertices[nIndex++] = vertices[index+2];											} else {												v.x = vertices[index];						v.y = vertices[index+1];						v.z = vertices[index+2];												v = applyRotations(v, t);												v.x += scenePosX;						v.y += scenePosY;						v.z += scenePosZ;												nvertices[nIndex++] = v.x;						nvertices[nIndex++] = v.y;						nvertices[nIndex++] = v.z;					}										nuvs[nIndexuv++] = uvs[indexuv];					nuvs[nIndexuv++] = uvs[indexuv+1];				} 			} 						geometries = geometry.subGeometries;			numSubGeoms = geometries.length;			for (i = 0; i < numSubGeoms; ++i){				subGeom = SubGeometry(geometries[i]);				subGeom.updateVertexData(vectors[i][0]);				subGeom.updateIndexData(vectors[i][1]);				subGeom.updateUVData(vectors[i][2]);			}						vectors = null;						for (i = 0; i<mesh1.subMeshes.length; ++i){				if(MaterialBase(materials[i]) != null)				 	mesh1.subMeshes[i].material = materials[i];			}						if(_disposeSources){				if(_keepMaterial)					mesh2.geometry.dispose();				else					mesh2.dispose(true);				mesh2 = null;			}						if(!_objectspace)				v = null;		}				private function parseContainer(object:ObjectContainer3D):void		{			var child:ObjectContainer3D;						if(object is Mesh && object.numChildren == 0){				if(!_m1){					_m1 = Mesh(object);				} else {					apply(_m1, Mesh(object));				}			}			 			for(var i:uint = 0;i<object.numChildren;++i){				child = object.getChildAt(i);				if(child!=_m1)					parseContainer(child);			}		}				private function applyRotations(v:Vertex, t:Matrix3D):Vertex		{			if(_holder == null)				_holder = new Vector3D();						_holder.x = v.x;			_holder.y = v.y;			_holder.z = v.z;						_holder = t.deltaTransformVector(_holder);						v.x = _holder.x;			v.y = _holder.y;			v.z = _holder.z;						return v;		}		 	}}